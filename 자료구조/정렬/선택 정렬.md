# 선택 정렬
<p align="center">
 <img src="https://blog.kakaocdn.net/dn/bb8tQu/btrJU0B7qfY/WUZh6MNJtJqkdWdKl1ncK0/img.gif" width="500">
</p>

## 과정
1. 리스트의 최솟값을 찾는다.
2. 이후 최솟값과 맨 앞의 값을 교체한다.
3. 반복한다.

### 코드
```
#include <stdio.h>
int main()
{
    int n, i, j, a[1001], temp, minIdx;
    scanf("%d", &n);        // 데이터의 개수 n을 정한다.
    for (i = 0; i < n; i++) // n개만큼 데이터의 값을 받는다.
    {
        scanf("%d", &a[i]);
    }
    // 선택 정렬 시작
    for (i = 0; i < n - 1; i++) // 마지막 값은 자동 정렬이 되었기에 비교할 필요가 없으므로 n-1번까지 반복한다.
    {
        minIdx = i; // 최소값 인덱스를 설정한다.
        for (j = i + 1; j < n; j++) // 비교값을 반복하는 것이므로 i+1번위치에서 마지막위치인 n번까지 반복한다.
        {
            if (a[minIdx] > a[j]) // 만약 최소값인 a[minIdx]보다 비교값이 더 작을 때 비교값 인덱스를 기억한다.
            {
                minIdx = j;
            }
        }
        // 비교가 끝났으므로 현재 위치값인 a[i]와 최소값인 a[minIdx]를 바꿔준다.
        temp = a[i];
        a[i] = a[minIdx];
        a[minIdx] = temp;
    }
    // 선택 정렬 끝났으므로 출력한다.
    for (i = 0; i < n; i++)
    {
        printf("%d ", a[i]);
    }
    return 0;
}
```
### 시간 복잡도
루프를 (N-1)번 도는 동안, 자리에 와야할 최댓값을 구하기 위해 N-1, N-2, N-3, ... , 1번의 비교연산을 수행한다.

__T(n) = (n-1)+(n-2)+(n-3)+...+1 = (n-1)*n/2__

시간복잡도는 `O(n) = n^2` 이다.

참고: 티스토리 경아ㅏ, 묠니르묘묘묘